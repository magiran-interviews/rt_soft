# Сервис получения случайного изображения

## Задание

Задача - сделать сервис просмотра контента. Он должен представлять из себя простой веб-сервис, написанный на python 3 с использованием любых показавшихся необходимыми библиотек.

Есть не изменяемый файл конфигурации в CSV, который содержит данные вида:
```
Image_URL;needed_amount_of_shows;category1;category2;category3; … ;category N
```

Количество записей в файле не более 1000.<br>
Файл содержит только символы.<br>
Необходимое количество показов  - сколько раз картинку нужно показать.<br>
Категорий у одной картинки может быть от 1 до 10 штук, записанных в соответствующих колонках.

Пример:
```
http://localhost:8080/static/image1.jpg;500;flight;airlplane
http://localhost:8080/static/image2.jpg;3300;show;britain;bennyhill;sketches;tv
http://localhost:8080/static/image3.jpg;1500;games;minecraft;blocks;sandbox
http://localhost:8080/static/image4.jpg;120;onlycategory
```

При запуске сервис считывает конфигурационный файл и начинает слушать HTTP обращения.<br>
Клиент HTTP GET запросом сообщает категории, которые он готов принять, к примеру:<br>
`http://localhost:8080/?category=animals&category=lakes`<br>
Количество запрошенных категорий может быть от 0 до 10 штук.

В ответ на него сервис должен выдавать простую HTML обертку с изображением картинки, которая совпадает минимум по одной категории.<br>
Категории картинки произвольны если в запросе категорий не указано.<br>
Каждый показ вычитается из количества необходимых к показу.

По характеру запросов считаем, что:
1. не будут запрашиваться категории, которых нет в конфигурационном файле.
1. количество запрошенных категорий равновероятно в рамках 0-10.
1. появление любой из категорий в запросе равновероятно.

Дополнительные плюсы:
1. Код соответствует PEP8.
1. Механизм, который уменьшает вероятность выдачи одной и той же картинки несколько раз подряд 
1. Механизм, позволяющий минимизировать вероятность возникновения случаев, когда подходящие картинки уже исчерпали свой лимит и ответить на запрос нечем.

## Решение

1. Для генерации файла CSV с параметрами отображения фотографий нужно назначить константы в файле `gen_csv.py` и запустить `generate_csv(line_cnt=1000)`.
1. Веб-сервис написал на FastAPI. Запуск проекта:
    ```bash
    uvicorn main:app --reload
    ```
1. Во время запуска проекта считывается CSV файл и информация по изображениям записывается в кеш redis сервера. Там хранится актуальная информация по кол-ву оставшихся показов для каждого изображения. После каждого получения изображения информация пересчитывается.<br>
    - В redis используются хеш-таблицы и множества для быстрого доступа к нужным объектам. В основном доступ O(1), кроме объединения множеств. Более подробно тут в комментарии `apps.random_photo.cache.PhotosInfoRedisWriter.write()`
    - Чтобы без проблем перенести хранение статистики с redis на что-нибудь другое используется паттерн "Инъекция зависимости".<br>
      Для этого написаны два интерфейса со следующими методами:
        - `PhotosInfoWriterInterface`
            - write() - метод записи начальной статистики из CSV файла в выбранное место хранения
        - `PhotosInfoGetterInterface`
            - get_random_photo_from_categories(categories: list[str]) - метод получения случайного изображения из любой категории переданного списка категорий.
            - get_random_photo_from_all_categories() - метод получения случайного изображения из списка всех возможных изображений.

      На этих интерфейсах реализованы классы записи/получения статистики изображений на redis сервере: `PhotosInfoRedisWriter` и `PhotosInfoRedisGetter`<br>
      Для изменения места/структуры хранения статистики нужно реализовать классы на данных интерфейсах и подменить на них здесь:
        - `main.photos_info_writer`
        - `apps.random_photo.router.get_photo_getter()`
1. В каталоге `apps` приложения проекта. Сейчас одно приложение `random_photo`.
1. Эндпоинт для пролучения случайного изображения `/random_photo/?category=name_1&category=name_2...`<br>
    Изображение отдаётся по следующему принципу:
    - Если категории не переданы, то случайным образом (через `redis.hrandfield('photos')`) получаем изображение из списка всех доступных изображений.
    - Если передана хотя бы одна категория, то объединяем множества изображений (`redis.sunion(categories_keys)`) этих категорий. В полученном множестве хранится список уникальных изображений, из него случайно выбираем одно.<br>
        То есть,
        - чем больше изображений в категории тем чаще из этой категории получаем изображения
        - фотографии из категорий равномерно исчерпываются, в идеальном случае не будет категорий, которые значительно быстрее других исчерпаются.
    - Если нет изображений соответствующих переданному фильтру, получаем изображение `PhotoInfo.null_object`, это объект по паттерну "Null Object".

По поводу списка "Дополнительные плюсы" из задания:
- "Код соответствует PEP8"<br>
Flake8 не использовал, но старался писать по PEP8
- "Механизм, который уменьшает вероятность выдачи одной и той же картинки несколько раз подряд"<br>
Использованный принцип отбора изображений даёт вероятность отдать несколько раз подряд одно изображение равную `(1/n)^(k-1)`, где
    - n - все фотографии подходящие под фильтр
    - k - сколько раз подряд отдаётся изображение<br>

    То есть шанс не очень большой, но он не исключён. Чтобы исключить, можно запоминать последний отданные изображения, но это не реализованно.
- "Механизм, позволяющий минимизировать вероятность возникновения случаев, когда подходящие картинки уже исчерпали свой лимит и ответить на запрос нечем"<br>
    - В `PhotoInfo.null_object` по паттерну "Null Object" реализованно изображение по умолчанию. Оно отдаётся если под пользовательский фильтр не попало ни одно изображение. Сейчас оно статичное. Можно добавить, например, список изображением с неисчерпаемым кол-вом показов. Тут минус, что рано или поздно придём только к этим дефолтным изображениям.<br>
    - Можно подгружать из CSV категории в которых все фотографии уже показанны максимальное кол-во раз.
    - Можно вести статистику, какой процент изображений остался в категории не показанным, и, допустим, при 20% подгружать в категорию изображения из CSV.
    - Можно следить какой процент изображений осталось для показа, и при тех же 20% заного загружать весь CSV. Получим изначальные фотографии с теми же вероятностями для отображения.
    - Можно ещё много вариантов придумать...

    Структуры данных (хеш-таблица и множества) в redis подобранны таким образом, чтобы можно было в любую переменную добавить/удалить одну любую фотографию за O(1) без пересоздания всей переменной.
